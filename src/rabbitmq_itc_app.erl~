-module(rabbitmq_itc).
-behaviour(gen_server).
-include_lib("amqp_client/include/amqp_client.hrl").
%%-include_lib("rabbit_common/include/rabbit.hrl").
%%-include_lib("rabbit_common/include/rabbit_framing.hrl").
-include_lib("/usr/lib/erlang/lib/stdlib-1.18.1/include/qlc.hrl").
-compile([export_all]).
-define(X, <<"amq.rabbitmq.trace">>).
-define(FileName, "/home/anna/itc_stamps.log").
-record(state, {conn, ch,queue,stamp}).
-record(log_record, {id, type, exchange, queue, node, connection,channel,
			vhost, username, routing_keys, routed_queues,payload,stamp}). 


start_link([]) -> 
   gen_server:start_link(?MODULE, [], []).

init(Args) ->
    {ok, Conn} = amqp_connection:start( #amqp_params_network{}),
    link(Conn),
    {ok, Ch} = amqp_connection:open_channel(Conn),
    link(Ch),
    #'queue.declare_ok'{queue = Q} =
        amqp_channel:call(Ch, #'queue.declare'{durable   = false, exclusive = true}),
    #'queue.bind_ok'{} =
    amqp_channel:call(
      Ch, #'queue.bind'{exchange = ?X, queue = Q,
                        routing_key = <<"#">>}),
    #'basic.qos_ok'{} =
        amqp_channel:call(Ch, #'basic.qos'{prefetch_count = 10}),
    #'basic.consume_ok'{} =
        amqp_channel:subscribe(Ch, #'basic.consume'{queue  = Q,no_ack = false}, self()),
    file:open("/home/anna/itc_please.txt",[append]),
    mnesia:create_schema([node()]),
    mnesia:start(),
    mnesia:create_table(log_record,
      [{attributes,record_info(fields,log_record)}, {record_name, log_record}, {type, ordered_set}]), 
    {ok, #state{conn = Conn, ch = Ch, queue = Q,stamp = itc:seed()} }.

handle_call(_Req, _From, State) ->
    {reply, unknown_request, State}.

handle_info(Delivery = {#'basic.deliver'{delivery_tag = Seq}, #amqp_msg{}},
            State = #state{ch = Ch}) ->
    New_state = header_information(Delivery, State),
    amqp_channel:cast(Ch, #'basic.ack'{delivery_tag = Seq}),
    {noreply, New_state};

handle_info(I, State) ->
    {noreply, State}.


table_lookup(Table, Key) ->
    case lists:keysearch(Key, 1, Table) of
        {value, {_, TypeBin, ValueBin}} -> {TypeBin, ValueBin};
        false                           -> undefined
    end.

log(Record) ->
     case  file:open(?FileName, [append]) of
       {ok, Io} ->  
            Fmt = "Message type : ~s~n~n"
                  "Node : ~s~n~n"
                  "Exchange: ~s~n~n" ++
		   case Record#log_record.queue of 
			     none -> "";
			        _ -> "Queue: ~s~n~n"
		    end ++
		   "User name: ~s~n~n"
		   "Routing key : ~s~n~n"
		   "Payload : ~s~n~n"
                   "Interval tree clock stamp : ~s ~n~n " 
                   "Virtual host: ~s~n"
                   "Connection: ~s~n Channel: ~p~n",
				
              Stamp = Record#log_record.stamp,
              Stamp_print = lists:flatten(io_lib:format("~p", [Stamp])),

            %%  N = rabbit_exchange:lookup(Record#log_record.vhost,  ,Record#log_record.exchange),
              %%N =rabbit_exchange:lookup(#resource{virtual_host = Record#log_record.vhost,
	      %%				name = Record#log_record.exchange, kind = exchange}),        
              [{_,R}] = Record#log_record.routing_keys,
	      Args = [Record#log_record.type,Record#log_record.node,
                       Record#log_record.exchange]++
                      case Record#log_record.queue of
                                        none -> [];
                                          Q -> [Q]
                      end ++
                       [Record#log_record.username,R,
                        Record#log_record.payload ,Stamp_print, Record#log_record.vhost,
                         Record#log_record.connection,Record#log_record.channel],
                      
	      Data = io_lib:format(Fmt,Args),
              file:write(Io,Data),
              file:close(Io);   
        {error, Reason} ->
            io:format("~s open error  reason:~s~n", [?FileName, Reason])
        end.

header_information(Delivery = { #'basic.deliver'{routing_key = Key,delivery_tag =D}, 
                       #amqp_msg{props = #'P_basic'{headers = H},payload = Payload}}, 
                       State = #state{conn = Conn, ch = Ch}) ->
         {Type, Q, RQs} = case Key of
				<<"publish.", _Rest/binary>> ->
					V = table_lookup(H, <<"routed_queues">>),
					{published, none, q};
				<<"deliver.", Rest/binary>> ->
					{received, Rest, none}
			     end,
          %%method_fieldnames('basic.deliver') -> [consumer_tag, delivery_tag, redelivered, exchange, routing_key];
          {longstr, Node} = table_lookup(H, <<"node">>),
          {longstr, X} = table_lookup(H, <<"exchange_name">>),
          {array, Keys} = table_lookup(H, <<"routing_keys">>),
          {table, Props} = table_lookup(H, <<"properties">>),
          {longstr, C} = table_lookup(H, <<"connection">>),
          {longstr, VHost} = table_lookup(H, <<"vhost">>),
          {longstr, User} = table_lookup(H, <<"user">>),
          {signedint, Chan} = table_lookup(H, <<"channel">>),
          Record = #log_record{type = Type, 
                              exchange = X,
                              queue = Q,
                              node = Node,
                              connection = C,
                              vhost = VHost,
                              username = User,
                              routing_keys = Keys,
                              payload = Payload,
                              channel = Chan
                             },     
          %%{New_record, New_state} = if Type == publish ->
          %%	 				publish_message(Record,State);
          %%   			       true -> 
          %%                                   received_message(Record,State)
          %%                          end,
          {New_record, New_state} = publish_message(Record,State),
          log(New_record),
          New_state.

do(Q) ->
    F = fun() -> qlc:e(Q) end,
    {atomic, Val} = mnesia:transaction(F),
    Val.

publish_message(Record,State=#state{stamp = User_number}) ->
	case mnesia:table_info(log_record,size) of 
			0 -> {New_stamp, User_stamp} = itc:fork(User_number),
                             Add_event_to_stamp = itc:event(User_stamp),
                             Update_record = Record#log_record{id = 1,stamp = Add_event_to_stamp}, 
  			    
                             F = fun() ->
				     mnesia:write(Update_record) 
		                 end,
		             mnesia:transaction(F),
                             {Update_record,State#state{ stamp = New_stamp} } ;
			N -> User_events  = do(qlc:q([X#log_record.stamp || X <- mnesia:table(log_record), 
		                   X#log_record.node == Record#log_record.node, 
		                   X#log_record.connection == Record#log_record.connection,
		                   X#log_record.channel == Record#log_record.channel,
		                   X#log_record.vhost == Record#log_record.vhost,
		                   X#log_record.username == Record#log_record.username])),

                            if 
                                  User_events == [] -> 
                                       {New_stamp, User_stamp} = itc:fork(User_number),
                                       Add_event_to_stamp = itc:event(User_stamp), 
                                       Update_record = Record#log_record{id = N+1,stamp = Add_event_to_stamp},   
                                       F = fun() ->
				               mnesia:write(Update_record) 
		                            end,
		                       mnesia:transaction(F),
                                       {Update_record,State#state{ stamp = New_stamp} } ;
                                  true ->  
                                       [Last|_Rest] = lists:reverse(User_events),
                                       New_user_event = itc:event(Last),
                                       Update_record = Record#log_record{id = N+1, stamp = New_user_event},
                                       F = fun() ->
				               mnesia:write(Update_record ) 
		                            end,
		                       mnesia:transaction(F),
                                       {Update_record,State}
                            end                   
        end.

received_message(Record,State=#state{stamp = User_number}) -> 
        %% ищу отправителя {exchange,payload,type}
        User_events  = do(qlc:q([X#log_record.stamp || X <- mnesia:table(log_record), 
		                   X#log_record.node == Record#log_record.node, 
		                   X#log_record.connection == Record#log_record.connection,
		                   X#log_record.channel == Record#log_record.channel,
		                   X#log_record.vhost == Record#log_record.vhost,
		                   X#log_record.username == Record#log_record.username])),
        Size_of_records = mnesia:table_info(log_record,size),
        {Update_record, New_state} = 
          case Record#log_record.exchange of
             <<"fanout">>  -> Possible_produsers  = do(qlc:q([X#log_record.stamp || X <- mnesia:table(log_record), 
		                  X#log_record.exchange == Record#log_record.exchange, 
		                  X#log_record.payload == Record#log_record.payload,
		                  X#log_record.type == published])),
                              {Mess_count,Last,New_stamp_state} = 
                                if User_events == [] ->
                                     {New_stamp, User_stamp} = itc:fork(User_number),
                                     {0,User_stamp,New_stamp};
                                   true -> 
                                     Same_consumers_mess = 
                                     lists:filter(fun(X) -> X#log_record.exchange == Record#log_record.exchange ,
                                                            X#log_record.payload == Record#log_record.payload ,
                                                            X#log_record.queue == Record#log_record.queue end,User_events),
                                     [L|_Rest] = lists:reverse(User_events), 
                                     {lists:length(Same_consumers_mess),L,none}
                                end,
                              [Produser|_] = lists:nthtail(Mess_count, Possible_produsers),
                              Event_for_join = itc:peek(Produser#log_record.stamp),
                              Receive_message  = itc:join(Event_for_join,Last),
                              New_event = itc:event(Receive_message),
                              {Record#log_record{id = Size_of_records + 1,stamp = New_event}, New_stamp_state};
             true ->
                      {Record,State}
          end.
    
terminate(shutdown, _State = #state{conn = Conn, ch = Ch}) ->
    catch amqp_channel:close(Ch),
    catch amqp_connection:close(Conn),
    ok;
terminate(_Reason, _State) ->
    ok.
